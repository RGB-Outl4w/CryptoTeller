<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RGB | Crypto Price Tracker</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    
    body {
      background-color: #ffffff;
      color: #333333;
      line-height: 1.6;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    header {
      text-align: center;
      padding: 30px 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.9) 100%);
      border-radius: 12px;
      margin-bottom: 30px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.05);
      position: relative;
    }
    
    .logo {
      font-size: 36px;
      font-weight: 800;
      margin-bottom: 5px;
      background: linear-gradient(90deg, #ff5e62, #4CAF50, #2196f3);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      display: inline-block;
    }
    
    .subtitle {
      font-size: 18px;
      color: #666;
      margin-bottom: 20px;
      line-height: 1.4;
    }
    
    .crypto-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 40px;
    }
    
    .crypto-card {
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.05);
      overflow: hidden;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .crypto-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
    }
    
    .card-header {
      padding: 15px 20px;
      display: flex;
      align-items: center;
      gap: 15px;
      border-bottom: 1px solid #f0f0f0;
    }
    
    .crypto-icon {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background-position: center;
      background-size: cover;
      background-repeat: no-repeat;
    }
    
    .crypto-icon-fallback {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: #f5f5f5;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
    }
    
    .crypto-title {
      flex: 1;
    }
    
    .crypto-name {
      font-size: 18px;
      font-weight: 600;
    }
    
    .crypto-name-link {
      color: inherit;
      text-decoration: none;
      position: relative;
      display: inline-block;
      transition: all 0.3s ease;
    }
    
    .crypto-name-link:hover {
      color: #2196f3;
      text-shadow: 0 0 8px rgba(33, 150, 243, 0.4);
      transform: translateY(-1px);
    }
    
    .crypto-name-link::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 2px;
      bottom: -2px;
      left: 0;
      background-color: #2196f3;
      transform: scaleX(0);
      transform-origin: bottom right;
      transition: transform 0.3s ease;
    }
    
    .crypto-name-link:hover::after {
      transform: scaleX(1);
      transform-origin: bottom left;
    }
    
    .modal-crypto-card .crypto-name-link {
      font-size: 22px;
    }
    
    .crypto-symbol {
      font-size: 14px;
      color: #666;
    }
    
    .card-body {
      padding: 20px;
    }
    
    .price {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 10px;
    }
    
    .price-change {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      font-weight: 500;
    }
    
    .positive {
      color: #4CAF50;
    }
    
    .negative {
      color: #ff5e62;
    }
    
    .stats {
      margin-top: 15px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    
    .stat-item {
      margin-bottom: 5px;
    }
    
    .stat-label {
      font-size: 12px;
      color: #888;
    }
    
    .stat-value {
      font-size: 14px;
      font-weight: 600;
    }
    
    .telegram-section {
      text-align: center;
      margin: 40px 0;
      padding: 30px;
      background: linear-gradient(135deg, rgba(255,94,98,0.05) 0%, rgba(76,175,80,0.05) 50%, rgba(33,150,243,0.05) 100%);
      border-radius: 12px;
    }
    
    .telegram-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 15px;
      color: #333;
    }
    
    .telegram-description {
      max-width: 600px;
      margin: 0 auto 20px;
      color: #666;
    }
    
    .telegram-button {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      background: linear-gradient(90deg, #ff5e62, #4CAF50, #2196f3);
      color: white;
      text-decoration: none;
      padding: 12px 24px;
      border-radius: 30px;
      font-weight: 600;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .telegram-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(33,150,243,0.3);
    }
    
    .telegram-icon {
      width: 24px;
      height: 24px;
    }
    
    footer {
      text-align: center;
      padding: 30px 0;
      color: #666;
      border-top: 1px solid #f0f0f0;
    }
    
    .footer-logo {
      font-weight: 700;
      background: linear-gradient(90deg, #ff5e62, #4CAF50, #2196f3);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      display: inline-block;
    }
    
    .refresh-button {
      display: block;
      margin: 0 auto 30px;
      background: white;
      border: 1px solid #eee;
      padding: 10px 20px;
      border-radius: 30px;
      font-size: 16px;
      font-weight: 500;
      color: #666;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .refresh-button:hover {
      background: #f9f9f9;
      color: #333;
    }
    
    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 300px;
    }
    
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #2196f3;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    .error-message {
      text-align: center;
      color: #ff5e62;
      margin: 20px 0;
      padding: 15px;
      border: 1px solid #ff5e62;
      border-radius: 8px;
      background-color: rgba(255, 94, 98, 0.05);
    }
    
    .last-updated {
      text-align: center;
      font-size: 14px;
      color: #888;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .search-container {
      max-width: 600px;
      margin: 0 auto 20px;
      position: relative;
    }
    
    .search-wrapper {
      display: flex;
      align-items: center;
      position: relative;
    }
    
    .search-input {
      width: 100%;
      padding: 12px 45px 12px 15px;
      border: 1px solid #eee;
      border-radius: 30px;
      font-size: 16px;
      outline: none;
      transition: all 0.3s ease;
    }
    
    .search-input:focus {
      border-color: #2196f3;
      box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
    }
    
    .search-button {
      position: absolute;
      right: 5px;
      height: 36px;
      width: 36px;
      border: none;
      background: transparent;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      border-radius: 50%;
      transition: all 0.3s ease;
    }
    
    .search-button:hover {
      color: #2196f3;
      background: rgba(33, 150, 243, 0.1);
    }
    
    .search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border-radius: 12px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      z-index: 10;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
    }
    
    .search-results.active {
      max-height: 400px;
      padding: 10px 0;
      overflow-y: auto;
    }
    
    .search-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 15px;
    }
    
    .search-loading-spinner {
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #2196f3;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }
    
    .result-item {
      display: flex;
      align-items: center;
      padding: 10px 15px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    
    .result-item:hover {
      background-color: #f9f9f9;
    }
    
    .result-icon {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      margin-right: 10px;
    }
    
    .result-icon-fallback {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #f5f5f5;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      font-size: 12px;
      margin-right: 10px;
    }
    
    .result-info {
      flex: 1;
    }
    
    .result-name {
      font-weight: 500;
      font-size: 14px;
    }
    
    .result-symbol {
      font-size: 12px;
      color: #666;
    }
    
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    
    .modal-crypto-card {
      max-width: 500px;
      width: 100%;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      position: relative;
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }
    
    .modal-overlay.active .modal-crypto-card {
      transform: scale(1);
    }
    
    .modal-crypto-card .card-header {
      padding: 20px 25px;
    }
    
    .modal-crypto-card .crypto-icon,
    .modal-crypto-card .crypto-icon-fallback {
      width: 48px;
      height: 48px;
    }
    
    .modal-crypto-card .crypto-name {
      font-size: 22px;
    }
    
    .modal-crypto-card .crypto-symbol {
      font-size: 16px;
    }
    
    .modal-crypto-card .card-body {
      padding: 25px;
    }
    
    .modal-crypto-card .price {
      font-size: 32px;
      margin-bottom: 15px;
    }
    
    .modal-crypto-card .price-change {
      font-size: 18px;
    }
    
    .modal-crypto-card .stats {
      margin-top: 20px;
    }
    
    .modal-crypto-card .stat-label {
      font-size: 14px;
    }
    
    .modal-crypto-card .stat-value {
      font-size: 18px;
    }
    
    .modal-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.8);
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      transition: all 0.2s ease;
    }
    
    .modal-close:hover {
      background: rgba(255, 94, 98, 0.1);
      color: #ff5e62;
    }
    
    /* OutlawRGB link styling */
    .outlaw-link {
      display: inline-block;
      color: inherit;
      text-decoration: none;
      font-weight: 600;
      transition: color var(--transition-duration) var(--transition-timing), 
                 text-shadow var(--transition-duration) var(--transition-timing);
    }
    
    .outlaw-link:hover {
      color: #4CAF50;
      text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
    }
    
    /* Theme Toggle with synchronized transitions */
    .theme-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 30px;
      width: 50px;
      height: 26px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 5px;
      box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    .theme-toggle::before {
      content: '';
      position: absolute;
      left: 3px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: white;
      transform: translateX(0);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: transform var(--transition-duration) var(--transition-timing),
                  background-color var(--transition-duration) var(--transition-timing);
    }
    
    .theme-toggle .sun,
    .theme-toggle .moon {
      width: 16px;
      height: 16px;
      fill: currentColor;
      z-index: 1;
      transition: color var(--transition-duration) var(--transition-timing);
    }
    
    .theme-toggle .sun {
      color: #FF9800;
    }
    
    .theme-toggle .moon {
      color: #5C6BC0;
    }
    
    /* Theme styles */
    :root {
      --bg-color: #ffffff;
      --text-color: #333333;
      --card-bg: white;
      --card-border: #f0f0f0;
      --card-shadow: rgba(0,0,0,0.05);
      --header-bg: linear-gradient(135deg, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.9) 100%);
      --header-solid-bg: rgba(255,255,255,0.85); /* Solid color for transition state */
      --secondary-text: #666;
      --light-bg: #f9f9f9;
      --input-border: #eee;
      --search-shadow: rgba(0, 0, 0, 0.1);
      --modal-shadow: rgba(0, 0, 0, 0.2);
      --spinner-border: #f3f3f3;
      --transition-duration: 0.5s;
      --transition-timing: ease;
    }
    
    [data-theme="dark"] {
      --bg-color: #1a1a1a;
      --text-color: #e6e6e6;
      --card-bg: #252525;
      --card-border: #333;
      --card-shadow: rgba(0,0,0,0.1);
      --header-bg: linear-gradient(135deg, rgba(40,40,40,0.8) 0%, rgba(30,30,30,0.9) 100%);
      --header-solid-bg: rgba(35,35,35,0.85); /* Solid color for transition state */
      --secondary-text: #aaa;
      --light-bg: #333;
      --input-border: #444;
      --search-shadow: rgba(0, 0, 0, 0.3);
      --modal-shadow: rgba(0, 0, 0, 0.4);
      --spinner-border: #444;
    }
    
    [data-theme="dark"] .theme-toggle {
      background: rgba(0, 0, 0, 0.4);
    }
    
    [data-theme="dark"] .theme-toggle::before {
      transform: translateX(24px);
      background: #333;
    }
    
    /* Apply theme variables with synchronized transitions */
    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    header {
      background: var(--header-bg);
      box-shadow: 0 4px 20px var(--card-shadow);
      transition: box-shadow var(--transition-duration) var(--transition-timing);
      position: relative;
    }
    
    /* Special header background overlay for smooth transitions */
    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--header-solid-bg);
      opacity: 0;
      z-index: -1;
      border-radius: 12px;
      transition: opacity var(--transition-duration) var(--transition-timing);
    }
    
    /* During theme transition, show the solid background */
    .theme-transitioning header::before {
      opacity: 1;
    }
    
    /* Hide the header gradient during transition */
    .theme-transitioning header {
      background: none;
    }
    
    /* Special animation for header theme transition - removed as we're using a new approach */
    @keyframes headerThemeChange {
      0% {
        background: var(--header-bg);
        box-shadow: 0 4px 20px var(--card-shadow);
        opacity: 0;
      }
      1% {
        opacity: 1;
      }
      100% {
        background: var(--header-bg);
        box-shadow: 0 4px 20px var(--card-shadow);
        opacity: 1;
      }
    }
    
    .subtitle {
      color: var(--secondary-text);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    .crypto-card {
      background: var(--card-bg);
      box-shadow: 0 4px 20px var(--card-shadow);
      transition: background-color var(--transition-duration) var(--transition-timing),
                  box-shadow var(--transition-duration) var(--transition-timing),
                  transform 0.3s ease;
    }
    
    .card-header {
      border-bottom: 1px solid var(--card-border);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    .crypto-symbol {
      color: var(--secondary-text);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    .crypto-icon-fallback {
      background: var(--light-bg);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    .search-input {
      background-color: var(--card-bg);
      border-color: var(--input-border);
      color: var(--text-color);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    .search-results, .result-item {
      background: var(--card-bg);
      color: var(--text-color);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    .result-item:hover {
      background-color: var(--light-bg);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    .result-symbol {
      color: var(--secondary-text);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    .stat-label {
      color: var(--secondary-text);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    .result-icon-fallback {
      background: var(--light-bg);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    .modal-crypto-card {
      background: var(--card-bg);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    .loading-spinner {
      border-color: var(--spinner-border);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    .last-updated {
      color: var(--secondary-text);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    footer {
      border-top: 1px solid var(--card-border);
      color: var(--secondary-text);
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    /* Animate price updates */
    .price-update {
      animation: pulseFade 1.5s ease;
    }
    
    @keyframes pulseFade {
      0% { opacity: 0.6; transform: scale(0.98); }
      50% { opacity: 1; transform: scale(1.02); }
      100% { opacity: 1; transform: scale(1); }
    }
    
    /* Mobile Optimizations */
    @media (max-width: 768px) {
      .crypto-grid {
        grid-template-columns: 1fr;
      }
      
      .container {
        padding: 15px;
      }
      
      header {
        padding: 20px 15px;
        margin-bottom: 20px;
      }
      
      .logo {
        font-size: 28px;
      }
      
      .subtitle {
        font-size: 16px;
        margin-bottom: 15px;
      }
      
      .telegram-section {
        padding: 20px 15px;
        margin: 30px 0;
      }
      
      .telegram-title {
        font-size: 20px;
      }
      
      .telegram-description {
        font-size: 14px;
      }
      
      .telegram-button {
        padding: 10px 20px;
        font-size: 14px;
      }
      
      .modal-crypto-card {
        width: 90%;
        margin: 0 5%;
      }
      
      .modal-crypto-card .card-header {
        padding: 15px 20px;
      }
      
      .modal-crypto-card .card-body {
        padding: 15px 20px;
      }
      
      .modal-crypto-card .price {
        font-size: 24px;
      }
      
      .modal-crypto-card .price-change {
        font-size: 16px;
      }
      
      .search-container {
        margin-bottom: 15px;
      }
      
      .search-results.active {
        max-height: 300px;
      }
      
      /* Improve touch targets for mobile */
      .search-button {
        width: 44px;
        height: 44px;
      }
      
      .result-item {
        padding: 12px 15px;
        min-height: 44px;
      }
      
      .refresh-button {
        padding: 12px 24px;
        min-height: 44px;
      }
      
      .modal-close {
        width: 44px;
        height: 44px;
        top: 5px;
        right: 5px;
      }
    }
    
    /* Small phone optimizations */
    @media (max-width: 480px) {
      .logo {
        font-size: 24px;
      }
      
      .subtitle {
        font-size: 14px;
      }
      
      .crypto-card {
        border-radius: 8px;
      }
      
      .card-header {
        padding: 12px 15px;
      }
      
      .card-body {
        padding: 15px;
      }
      
      .price {
        font-size: 20px;
      }
      
      .price-change {
        font-size: 13px;
      }
      
      .crypto-name {
        font-size: 16px;
      }
      
      .crypto-symbol {
        font-size: 12px;
      }
      
      .stat-label {
        font-size: 11px;
      }
      
      .stat-value {
        font-size: 13px;
      }
      
      .error-message {
        font-size: 14px;
        padding: 12px;
      }
      
      .search-input {
        font-size: 14px;
        padding: 12px 44px 12px 15px;
      }
      
      /* Adjust modal for very small screens */
      .modal-crypto-card .crypto-name {
        font-size: 18px;
      }
      
      .modal-crypto-card .price {
        font-size: 22px;
      }
      
      /* Stack telegram button elements if needed */
      .telegram-button {
        padding: 10px 15px;
        font-size: 13px;
      }
    }
    
    /* Landscape orientation on mobile */
    @media (max-height: 500px) and (orientation: landscape) {
      .modal-overlay {
        align-items: flex-start;
        overflow-y: auto;
        padding: 20px 0;
      }
      
      .modal-crypto-card {
        margin: 0 auto;
      }
      
      .search-results.active {
        max-height: 200px;
      }
      
      .loading {
        min-height: 200px;
      }
    }
    
    /* Add safe area insets for modern mobile browsers */
    @supports (padding-bottom: env(safe-area-inset-bottom)) {
      .container {
        padding-left: max(20px, env(safe-area-inset-left));
        padding-right: max(20px, env(safe-area-inset-right));
        padding-bottom: max(20px, env(safe-area-inset-bottom));
      }
      
      .modal-overlay {
        padding-bottom: env(safe-area-inset-bottom);
      }
    }
    
    /* Fix for notched displays */
    @supports(padding: max(0px)) {
      body {
        padding-left: min(0px, env(safe-area-inset-left));
        padding-right: min(0px, env(safe-area-inset-right));
      }
    }
    
    /* Improve touch feedback for mobile */
    @media (hover: none) {
      .result-item:active, 
      .crypto-name-link:active,
      .telegram-button:active,
      .refresh-button:active,
      .search-button:active {
        opacity: 0.7;
      }
      
      /* Remove hover effects that don't work well on touch */
      .crypto-card:hover {
        transform: none;
      }
      
      /* Disable hover animations and replace with active state */
      .crypto-name-link:hover::after {
        transform: none;
      }
      
      .crypto-name-link:active::after {
        transform: scaleX(1);
        transform-origin: bottom left;
      }
    }
    
    /* Theme transitioning helper class */
    .theme-transitioning {
      pointer-events: none; /* Prevent interaction during transition */
    }
    
    /* Specific direction transitions for finer control */
    .theme-transitioning-to-dark header::before,
    .theme-transitioning-to-light header::before {
      opacity: 1;
    }
    
    /* CSS for smooth theme transition debugging - can be removed in production */
    .theme-transitioning * {
      /* Forces a repaint which can help with transition synchronization */
      transform: translateZ(0);
    }
    
    /* Ensure header children also have proper transitions */
    header *, .logo, .subtitle {
      transition: all var(--transition-duration) var(--transition-timing);
    }
    
    /* Special transition for gradient text (logo) */
    .logo, .footer-logo {
      transition: -webkit-text-fill-color var(--transition-duration) var(--transition-timing);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="logo">Real-time Cryptocurrency Price Tracker</div>
      <div class="subtitle">
        Brought to you by <a href="https://github.com/RGB-Outl4w" class="outlaw-link" target="_blank" rel="noopener noreferrer">OutlawRGB</a>
      </div>
      <button id="themeToggle" class="theme-toggle" aria-label="Toggle dark mode">
        <svg class="sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M12 17a5 5 0 1 0 0-10 5 5 0 0 0 0 10zm0-12a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 0-1 0v2a.5.5 0 0 0 .5.5zm0 14a.5.5 0 0 0-.5.5v2a.5.5 0 0 0 1 0v-2a.5.5 0 0 0-.5-.5zm7-7a.5.5 0 0 0-.5.5h2a.5.5 0 0 0 0-1h-2a.5.5 0 0 0 .5.5zm-13.657-5.657a.5.5 0 0 0 .707 0l1.414-1.414a.5.5 0 1 0-.707-.707l-1.414 1.414a.5.5 0 0 0 0 .707zM7.343 17.657a.5.5 0 0 0-.707 0l-1.414 1.414a.5.5 0 0 0 .707.707l1.414-1.414a.5.5 0 0 0 0-.707zM17.657 17.657a.5.5 0 0 0 0-.707l1.414 1.414a.5.5 0 0 0 .707-.707l-1.414-1.414a.5.5 0 0 0-.707 0zM7.343 6.343a.5.5 0 0 0 0 .707L5.929 5.636a.5.5 0 0 0-.707.707l1.414 1.414a.5.5 0 0 0 .707 0z"/>
        </svg>
        <svg class="moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M12 3a9 9 0 1 0 9 9c0-.46-.04-.92-.1-1.36a5.389 5.389 0 0 1-4.4 2.26 5.403 5.403 0 0 1-3.14-9.8c-.44-.06-.9-.1-1.36-.1z"/>
        </svg>
      </button>
    </header>
    
    <div class="search-container">
      <div class="search-wrapper">
        <input type="text" id="cryptoSearch" class="search-input" placeholder="Search cryptocurrency by name or symbol...">
        <button class="search-button" id="searchButton" title="Search cryptocurrency">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="8"></circle>
            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          </svg>
        </button>
      </div>
      <div class="search-results" id="searchResults"></div>
    </div>
    
    <div class="last-updated" id="lastUpdated">
      Last updated: Loading...
    </div>
    
    <div id="loadingContainer" class="loading">
      <div class="loading-spinner"></div>
      <div>Loading cryptocurrency data...</div>
    </div>
    
    <div id="errorContainer" style="display: none;"></div>
    
    <div class="crypto-grid" id="cryptoGrid" style="display: none;">
      <!-- Crypto cards will be dynamically inserted here -->
    </div>
    
    <div class="telegram-section">
      <h2 class="telegram-title">Get Instant Updates on Telegram</h2>
      <p class="telegram-description">
        Access real-time cryptocurrency prices anytime and anywhere with our Telegram bot. 
      </p>
      <a href="https://t.me/crypteller_bot" target="_blank" rel="noopener" class="telegram-button">
        <svg class="telegram-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21.5 2L2 10.75l7.5 3M21.5 2l-5 19.5-7-8M9.5 13.75l-3 8.25 7-8"></path>
        </svg>
        Open CryptoTeller Bot
      </a>
    </div>
    
    <footer>
      <p>© 2025 <span class="footer-logo">RGB.Development</span> • Powered by CoinGecko API</p>
    </footer>
  </div>

  <script>
    /**
     * Main application script for cryptocurrency price tracker
     * This app fetches data from CoinGecko API, handles caching,
     * and provides search and display functionality with fallbacks
     * for when API limits are reached.
     */

    // Store all cryptocurrency data fetched from API for search functionality
    let allCryptoData = [];
    
    // Auto refresh timer
    let autoRefreshTimer = null;
    
    // Store the currently changed prices for animation
    let changedPrices = {};

    /**
     * Theme management system
     * Handles toggling between light and dark themes with localStorage persistence
     * and synchronized transitions
     */
    const themeManager = {
      init: function() {
        // Set initial theme based on localStorage or system preference
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
          document.documentElement.setAttribute('data-theme', savedTheme);
        } else {
          // Check system preference
          const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
          if (prefersDark) {
            document.documentElement.setAttribute('data-theme', 'dark');
          }
        }
        
        // Add theme toggle event listener - handled in DOMContentLoaded now
        // for better synchronization
        
        // Listen for system preference changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
          // Only update if user hasn't manually set a preference
          if (!localStorage.getItem('theme')) {
            // Add transitioning class for smooth change
            document.documentElement.classList.add('theme-transitioning');
            
            setTimeout(() => {
              document.documentElement.setAttribute('data-theme', e.matches ? 'dark' : 'light');
            }, 50);
            
            // Remove transitioning class after transition completes
            setTimeout(() => {
              document.documentElement.classList.remove('theme-transitioning');
            }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--transition-duration')) * 1000 + 50);
          }
        });
      },
      
      toggleTheme: function() {
        const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        
        document.documentElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
      }
    };

    /**
     * API response cache system
     * Stores API responses in memory and localStorage with expiration times
     * to reduce API calls and provide data when offline or rate-limited
     */
    const apiCache = {
      // In-memory cache storage
      cache: {},
      
      /**
       * Get data from cache if valid and not expired
       * @param {string} key - Cache key to retrieve
       * @returns {object|null} - Cached data or null if invalid/expired
       */
      get: function(key) {
        const cachedItem = this.cache[key];
        if (!cachedItem) return null;
        
        // Check if cache entry is expired (5 minutes)
        const now = Date.now();
        if (now - cachedItem.timestamp > 5 * 60 * 1000) {
          delete this.cache[key];
          return null;
        }
        
        return cachedItem.data;
      },
      
      /**
       * Store data in cache with timestamp
       * Also persists to localStorage for reuse across sessions
       * @param {string} key - Cache key
       * @param {object} data - Data to store
       */
      set: function(key, data) {
        this.cache[key] = {
          data: data,
          timestamp: Date.now()
        };
        
        // Persist to localStorage for use across sessions
        try {
          const storageItem = {
            data: data,
            timestamp: Date.now()
          };
          localStorage.setItem('crypto_cache_' + key, JSON.stringify(storageItem));
        } catch (e) {
          console.warn('Failed to store in localStorage:', e);
        }
      },
      
      /**
       * Initialize cache from localStorage on page load
       * Restores previously cached data if not expired
       */
      init: function() {
        try {
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('crypto_cache_')) {
              const cacheKey = key.replace('crypto_cache_', '');
              const item = JSON.parse(localStorage.getItem(key));
              
              // Check if item is expired (10 minutes)
              const now = Date.now();
              if (now - item.timestamp <= 10 * 60 * 1000) {
                this.cache[cacheKey] = item;
              } else {
                localStorage.removeItem(key);
              }
            }
          }
        } catch (e) {
          console.warn('Failed to load from localStorage:', e);
        }
      }
    };
    
    /**
     * Request throttling system to manage API rate limits
     * Queues requests and implements exponential backoff for retries
     * when rate limits are encountered
     */
    const requestThrottler = {
      queue: [],
      inProgress: false,
      retryDelay: 1000,
      
      /**
       * Add a request to the queue for processing
       * @param {Function} requestFn - Function that returns a Promise for the API request
       * @param {Function} onSuccess - Callback for successful requests
       * @param {Function} onError - Callback for failed requests
       */
      add: function(requestFn, onSuccess, onError) {
        this.queue.push({
          requestFn,
          onSuccess,
          onError,
          attempt: 0
        });
        
        if (!this.inProgress) {
          this.processNext();
        }
      },
      
      /**
       * Process the next request in the queue
       * Implements retry logic with exponential backoff for rate limit errors
       */
      processNext: function() {
        if (this.queue.length === 0) {
          this.inProgress = false;
          return;
        }
        
        this.inProgress = true;
        const request = this.queue.shift();
        
        request.requestFn()
          .then(data => {
            request.onSuccess(data);
            // Small delay between requests to avoid rate limiting
            setTimeout(() => this.processNext(), 300);
          })
          .catch(error => {
            // Handle rate limit errors with exponential backoff
            if (error.status === 429 || error.message?.includes('rate limit')) {
              request.attempt++;
              const delay = Math.min(30000, this.retryDelay * Math.pow(2, request.attempt - 1));
              
              console.log(`Rate limit hit. Retrying in ${delay/1000} seconds...`);
              
              // Requeue with backoff if under max attempts
              if (request.attempt < 4) {
                setTimeout(() => {
                  this.queue.unshift(request);
                  this.processNext();
                }, delay);
              } else {
                request.onError(error);
                setTimeout(() => this.processNext(), 1000);
              }
            } else {
              request.onError(error);
              setTimeout(() => this.processNext(), 500);
            }
          });
      }
    };
    
    /**
     * Fallback data for popular cryptocurrencies
     * Used when the API is unavailable or rate-limited
     * Provides reasonable estimates for display
     */
    const popularCryptos = {
      'bitcoin': { id: 'bitcoin', name: 'Bitcoin', symbol: 'BTC', price: 58000, change: 2.5 },
      'ethereum': { id: 'ethereum', name: 'Ethereum', symbol: 'ETH', price: 3500, change: 1.8 },
      'dogecoin': { id: 'dogecoin', name: 'Dogecoin', symbol: 'DOGE', price: 0.12, change: 1.2 },
      'solana': { id: 'solana', name: 'Solana', symbol: 'SOL', price: 140, change: 3.1 },
      'ripple': { id: 'ripple', name: 'XRP', symbol: 'XRP', price: 0.5, change: -0.8 },
      'cardano': { id: 'cardano', name: 'Cardano', symbol: 'ADA', price: 0.45, change: 0.3 },
      'tether': { id: 'tether', name: 'Tether', symbol: 'USDT', price: 1, change: 0.01 },
      'binancecoin': { id: 'binancecoin', name: 'BNB', symbol: 'BNB', price: 580, change: 1.5 },
      'polkadot': { id: 'polkadot', name: 'Polkadot', symbol: 'DOT', price: 6.5, change: 0.7 }
    };

    // List of cryptocurrency IDs to fetch by default
    const cryptoIds = [
      'bitcoin',
      'ethereum',
      'solana',
      'the-open-network',
      'tether',
      'ripple',
    ];
    
    // Map of crypto IDs to their display names and symbols
    const cryptoMap = {
      'bitcoin': { name: 'Bitcoin', symbol: 'BTC' },
      'ethereum': { name: 'Ethereum', symbol: 'ETH' },
      'solana': { name: 'Solana', symbol: 'SOL' },
      'the-open-network': { name: 'Toncoin', symbol: 'TON' },
      'tether': { name: 'Tether', symbol: 'USDT' },
      'ripple': { name: 'XRP', symbol: 'XRP' },
    };

    /**
     * Format price values for display
     * Adjusts decimal places based on price magnitude
     * @param {number} price - The price value to format
     * @returns {string} - Formatted price string
     */
    function formatPrice(price) {
      if (price >= 1000) {
        return price.toLocaleString('en-US', { 
          minimumFractionDigits: 2,
          maximumFractionDigits: 2 
        });
      } else if (price >= 1) {
        return price.toLocaleString('en-US', { 
          minimumFractionDigits: 2,
          maximumFractionDigits: 2 
        });
      } else {
        return price.toLocaleString('en-US', { 
          minimumFractionDigits: 2,
          maximumFractionDigits: 4
        });
      }
    }
    
    /**
     * Format large numbers with B/M/T suffixes
     * @param {number} num - The number to format
     * @returns {string} - Formatted number with appropriate suffix
     */
    function formatLargeNumber(num) {
      if (num >= 1e12) {
        return (num / 1e12).toFixed(2) + 'T';
      } else if (num >= 1e9) {
        return (num / 1e9).toFixed(2) + 'B';
      } else if (num >= 1e6) {
        return (num / 1e6).toFixed(2) + 'M';
      } else {
        return num.toLocaleString();
      }
    }

    /**
     * Main function to fetch cryptocurrency price data
     * Handles API requests, caching, and fallback strategies
     */
    async function fetchCryptoPrices() {
      const loadingContainer = document.getElementById('loadingContainer');
      const errorContainer = document.getElementById('errorContainer');
      const cryptoGrid = document.getElementById('cryptoGrid');
      
      // Only show loading if grid is not already displayed
      if (cryptoGrid.style.display !== 'grid') {
        loadingContainer.style.display = 'flex';
      }
      
      errorContainer.style.display = 'none';
      
      // Store previous data for animation comparison
      changedPrices = {};
      if (allCryptoData.length > 0) {
        allCryptoData.forEach(crypto => {
          changedPrices[crypto.id] = {
            price: crypto.current_price,
            change: crypto.price_change_percentage_24h
          };
        });
      }
      
      // Check for cached data first
      const cacheKey = `markets_${cryptoIds.join('_')}`;
      const cachedData = apiCache.get(cacheKey);
      
      if (cachedData) {
        console.log('Using cached data');
        
        // Update the last updated timestamp
        const now = new Date();
        document.getElementById('lastUpdated').textContent = `Last updated: ${now.toLocaleString()} (cached)`;
        
        // Only animate if we had previous data
        const shouldAnimate = allCryptoData.length > 0;
        
        // Update our global data
        allCryptoData = cachedData;
        
        // Process and display the data
        renderCryptoCards(cachedData, shouldAnimate);
        
        // Show the grid and hide loading
        loadingContainer.style.display = 'none';
        cryptoGrid.style.display = 'grid';
        
        return;
      }
      
      try {
        // CoinGecko API endpoint for multiple coins
        const url = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${cryptoIds.join(',')}&order=market_cap_desc&per_page=100&page=1&sparkline=false&price_change_percentage=24h`;
        
        // Use the throttler for this request
        await new Promise((resolve, reject) => {
          requestThrottler.add(
            // Request function
            () => fetch(url).then(response => {
              if (!response.ok) {
                throw { status: response.status, message: `API request failed with status ${response.status}` };
              }
              return response.json();
            }),
            // Success handler
            (data) => {
              // Only animate if we had previous data
              const shouldAnimate = allCryptoData.length > 0;
              
              // Store the data in our global variable for search functionality
              allCryptoData = data;
              
              // Cache the successful response
              apiCache.set(cacheKey, data);
              
              // Update the last updated timestamp
              const now = new Date();
              document.getElementById('lastUpdated').textContent = `Last updated: ${now.toLocaleString()}`;
              
              // Process and display the data
              renderCryptoCards(data, shouldAnimate);
              
              // Show the grid and hide loading
              loadingContainer.style.display = 'none';
              cryptoGrid.style.display = 'grid';
              
              resolve();
            },
            // Error handler
            (error) => {
              console.error('Error fetching data:', error);
              
              // Try to use fallback data for the main currencies
              const fallbackData = cryptoIds.map(id => {
                const fallback = popularCryptos[id];
                if (fallback) {
                  return {
                    id: fallback.id,
                    name: fallback.name,
                    symbol: fallback.symbol,
                    current_price: fallback.price,
                    price_change_percentage_24h: fallback.change,
                    total_volume: 1000000000,
                    market_cap: 10000000000,
                    image: `https://assets.coingecko.com/coins/images/1/small/bitcoin.png`
                  };
                }
                return {
                  id: id,
                  name: cryptoMap[id]?.name || id,
                  symbol: cryptoMap[id]?.symbol || id.toUpperCase(),
                  current_price: 'N/A',
                  price_change_percentage_24h: 0,
                  total_volume: 'N/A',
                  market_cap: 'N/A',
                  image: null
                };
              });
              
              // Show error message
              errorContainer.innerHTML = `
                <div class="error-message">
                  <strong>Error loading data:</strong> ${error.message || 'Unknown error'}
                  <p>Using cached data where possible. This could be due to CoinGecko API rate limits.</p>
                </div>
              `;
              
              // Use fallback data
              renderCryptoCards(fallbackData, false);
              
              loadingContainer.style.display = 'none';
              errorContainer.style.display = 'block';
              cryptoGrid.style.display = 'grid';
              
              reject(error);
            }
          );
        });
      } catch (error) {
        console.error('Error in fetch flow:', error);
      } finally {
        // Schedule next auto-refresh (every 5 minutes)
        scheduleNextRefresh();
      }
    }
    
    /**
     * Schedule the next automatic refresh
     * Handles clearing existing timers and setting up new ones
     */
    function scheduleNextRefresh() {
      // Clear any existing timer
      if (autoRefreshTimer) {
        clearTimeout(autoRefreshTimer);
      }
      
      // Set next refresh for 5 minutes (300000 ms)
      autoRefreshTimer = setTimeout(() => {
        fetchCryptoPrices();
      }, 300000);
      
      console.log('Scheduled next auto-refresh for 5 minutes from now');
    }

    /**
     * Render cryptocurrency cards with data
     * Creates HTML elements for each crypto and adds them to the grid
     * @param {Array} cryptoData - Array of cryptocurrency data objects
     * @param {boolean} animate - Whether to animate changes
     */
    function renderCryptoCards(cryptoData, animate = false) {
      const grid = document.getElementById('cryptoGrid');
      grid.innerHTML = '';
      
      cryptoData.forEach(crypto => {
        const isPositive = crypto.price_change_percentage_24h > 0;
        const cardElement = document.createElement('div');
        cardElement.className = 'crypto-card';
        
        // Get display name and symbol from our map, or use API values as fallback
        const displayInfo = cryptoMap[crypto.id] || { 
          name: crypto.name, 
          symbol: crypto.symbol.toUpperCase() 
        };
        
        // Create the URL for the coin on CoinGecko
        const coinUrl = `https://www.coingecko.com/en/coins/${crypto.id}`;
        
        // Check if price has changed for animation
        let priceChanged = false;
        let changeDirection = '';
        
        if (animate && changedPrices[crypto.id]) {
          const oldPrice = changedPrices[crypto.id].price;
          const oldChange = changedPrices[crypto.id].change;
          
          // Only animate meaningful changes
          if (typeof oldPrice === 'number' && typeof crypto.current_price === 'number') {
            if (Math.abs(oldPrice - crypto.current_price) / oldPrice > 0.0001) {
              priceChanged = true;
              changeDirection = crypto.current_price > oldPrice ? 'increase' : 'decrease';
            }
          }
          
          // Also detect significant change in the 24h percentage
          if (typeof oldChange === 'number' && typeof crypto.price_change_percentage_24h === 'number') {
            if (Math.abs(oldChange - crypto.price_change_percentage_24h) > 0.1) {
              priceChanged = true;
            }
          }
        }
        
        cardElement.innerHTML = `
          <div class="card-header">
            ${crypto.image ? 
              `<div class="crypto-icon" style="background-image: url('${crypto.image}')"></div>` : 
              `<div class="crypto-icon-fallback" style="background-color: #${Math.floor(Math.random()*16777215).toString(16)}">
                ${displayInfo.symbol.charAt(0)}
              </div>`
            }
            <div class="crypto-title">
              <div class="crypto-name">
                <a href="${coinUrl}" target="_blank" rel="noopener noreferrer" class="crypto-name-link" title="View ${displayInfo.name} on CoinGecko">
                  ${displayInfo.name}
                </a>
              </div>
              <div class="crypto-symbol">${displayInfo.symbol}</div>
            </div>
          </div>
          <div class="card-body">
            <div class="price ${priceChanged ? 'price-update' : ''}" data-change="${changeDirection}">$${formatPrice(crypto.current_price)}</div>
            <div class="price-change ${isPositive ? 'positive' : 'negative'} ${priceChanged ? 'price-update' : ''}">
              ${isPositive ? '↑' : '↓'} ${Math.abs(crypto.price_change_percentage_24h).toFixed(2)}%
            </div>
            <div class="stats">
              <div class="stat-item">
                <div class="stat-label">Volume (24h)</div>
                <div class="stat-value">$${formatLargeNumber(crypto.total_volume)}</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">Market Cap</div>
                <div class="stat-value">$${formatLargeNumber(crypto.market_cap)}</div>
              </div>
            </div>
          </div>
        `;
        
        grid.appendChild(cardElement);
      });
    }

    // Track search operations that are in progress to prevent duplicates
    const searchInProgress = {};
    
    // Initialize the application when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize cache from localStorage
      apiCache.init();
      
      // Initialize theme manager
      themeManager.init();
      
      const searchInput = document.getElementById('cryptoSearch');
      const searchResults = document.getElementById('searchResults');
      const searchButton = document.getElementById('searchButton');
      
      // Search input debounce timer
      let searchDebounceTimer;
      
      // Search input event listener with debouncing
      searchInput.addEventListener('input', function(event) {
        // Clear any existing timer
        clearTimeout(searchDebounceTimer);
        
        // Set a new timer to execute search after user stops typing
        searchDebounceTimer = setTimeout(() => {
          handleSearch(event);
        }, 800); // 800ms debounce time
      });
      
      // Search button click event
      searchButton.addEventListener('click', () => {
        clearTimeout(searchDebounceTimer);
        handleSearch({ target: searchInput });
      });
      
      // Close search results when clicking outside
      document.addEventListener('click', function(event) {
        if (!event.target.closest('.search-container')) {
          searchResults.classList.remove('active');
        }
      });
      
      // Handle Enter key in search input
      searchInput.addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
          clearTimeout(searchDebounceTimer);
          const firstResult = searchResults.querySelector('.result-item');
          if (firstResult && !firstResult.classList.contains('loading-item') && firstResult.textContent !== 'No results found' && firstResult.textContent !== 'Error searching. Try again later.') {
            firstResult.click();
          }
        }
      });
      
      // Enhanced theme toggling with better synchronization
      const themeToggle = document.getElementById('themeToggle');
      if (themeToggle) {
        themeToggle.addEventListener('click', function() {
          // Remove any existing animation that might still be running
          document.querySelectorAll('.theme-transitioning').forEach(el => {
            el.classList.remove('theme-transitioning');
          });
          
          // Get current theme to determine transition direction
          const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
          const newTheme = currentTheme === 'light' ? 'dark' : 'light';
          
          // Add transitioning-to class to help with specific transitions
          document.documentElement.classList.add(`theme-transitioning-to-${newTheme}`);
          
          // Add a special class to help with transition synchronization
          document.documentElement.classList.add('theme-transitioning');
          
          // For the header, apply special handling
          const header = document.querySelector('header');
          if (header) {
            // Temporarily force the header to use solid background color during transition
            header.style.background = 'none';
          }
          
          // Delay the actual theme change slightly to ensure all elements are ready to transition
          setTimeout(() => {
            themeManager.toggleTheme();
          }, 50);
          
          // Remove the transition classes when transitions are likely complete
          const transitionDuration = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--transition-duration')) * 1000 + 50;
          
          setTimeout(() => {
            document.documentElement.classList.remove('theme-transitioning');
            document.documentElement.classList.remove(`theme-transitioning-to-${newTheme}`);
            
            // Restore header background
            if (header) {
              header.style.background = '';
            }
          }, transitionDuration);
        });
      }
      
      // Initial fetch and auto-refresh setup
      fetchCryptoPrices();
    });

    /**
     * Handle search input and show results
     * Uses multiple sources: local data, cached results, and API search
     * @param {Event} event - The event that triggered the search
     */
    function handleSearch(event) {
      const searchTerm = event.target.value.trim().toLowerCase();
      const searchResults = document.getElementById('searchResults');
      
      // Clear previous results
      searchResults.innerHTML = '';
      
      if (searchTerm.length < 2) {
        searchResults.classList.remove('active');
        return;
      }
      
      // Show searching state immediately
      searchResults.innerHTML = `
        <div class="search-loading">
          <div class="search-loading-spinner"></div>
          <div>Searching cryptocurrencies...</div>
        </div>
      `;
      searchResults.classList.add('active');
      
      // Check if we have popular crypto matching the search
      const popularMatches = Object.values(popularCryptos).filter(crypto => 
        crypto.name.toLowerCase().includes(searchTerm) || 
        crypto.symbol.toLowerCase().includes(searchTerm)
      );
      
      // Filter existing loaded cryptocurrencies based on search term
      const matchingCryptos = allCryptoData.filter(crypto => 
        crypto.name.toLowerCase().includes(searchTerm) || 
        crypto.symbol.toLowerCase().includes(searchTerm)
      );
      
      // First check if we have cached search results
      const cacheKey = `search_${searchTerm}`;
      const cachedResults = apiCache.get(cacheKey);
      
      if (cachedResults) {
        console.log('Using cached search results');
        displaySearchResults(cachedResults, searchResults, event);
        return;
      }
      
      if (matchingCryptos.length > 0) {
        // Display results from existing data
        displaySearchResults(matchingCryptos, searchResults, event);
      } else if (popularMatches.length > 0) {
        // Convert popular matches to expected format and display
        const formattedPopularMatches = popularMatches.map(crypto => ({
          id: crypto.id,
          name: crypto.name,
          symbol: crypto.symbol,
          image: `https://assets.coingecko.com/coins/images/1/small/${crypto.id}.png`,
          current_price: crypto.price,
          price_change_percentage_24h: crypto.change,
          total_volume: 1000000000,
          market_cap: 10000000000
        }));
        
        // Add a note that these are cached results
        searchResults.innerHTML = '<div class="result-item" style="background:#f9f9f9;cursor:default;">⚠️ Using cached data due to API limits</div>';
        displaySearchResults(formattedPopularMatches, searchResults, event);
      } else {
        // Search for cryptocurrency on CoinGecko API
        searchCoinGecko(searchTerm, searchResults, event);
      }
    }
    
    /**
     * Search for cryptocurrencies using CoinGecko API
     * Handles rate limits, caching, and fallback mechanisms
     * @param {string} searchTerm - The search query
     * @param {HTMLElement} searchResults - The results container element
     * @param {Event} event - The event that triggered the search
     */
    async function searchCoinGecko(searchTerm, searchResults, event) {
      // Check rate limit tracking in localStorage
      let rateLimitInfo = { count: 0, resetTime: 0 };
      try {
        const storedInfo = localStorage.getItem('cg_rate_limit');
        if (storedInfo) {
          rateLimitInfo = JSON.parse(storedInfo);
        }
      } catch (e) {
        console.warn('Failed to read rate limit info:', e);
      }
      
      const now = Date.now();
      
      // Reset count if the reset time has passed
      if (now > rateLimitInfo.resetTime) {
        rateLimitInfo = { count: 0, resetTime: now + 60000 }; // Reset in 1 minute
      }
      
      // Check if we're approaching rate limit (CoinGecko allows ~10-30 requests per minute)
      if (rateLimitInfo.count >= 25) {
        searchResults.innerHTML = `
          <div class="result-item">
            Rate limit protection active. Please try again in ${Math.ceil((rateLimitInfo.resetTime - now) / 1000)} seconds.
          </div>
        `;
        return;
      }
      
      // Increment count and save
      rateLimitInfo.count++;
      try {
        localStorage.setItem('cg_rate_limit', JSON.stringify(rateLimitInfo));
      } catch (e) {
        console.warn('Failed to save rate limit info:', e);
      }
      
      try {
        // First check if search is already in progress for this term
        if (searchInProgress[searchTerm]) {
          console.log('Search already in progress, waiting for results...');
          return;
        }
        
        searchInProgress[searchTerm] = true;
        
        // Use CoinGecko search API endpoint with proper error handling
        const searchUrl = `https://api.coingecko.com/api/v3/search?query=${encodeURIComponent(searchTerm)}`;
        
        // Check for cached search results first
        const cacheKey = `search_${searchTerm}`;
        const cachedResults = apiCache.get(cacheKey);
        
        if (cachedResults) {
          console.log('Using cached search results');
          displaySearchResults(cachedResults, searchResults, event);
          searchInProgress[searchTerm] = false;
          return;
        }
        
        // Use the throttler for this request
        await new Promise((resolve, reject) => {
          requestThrottler.add(
            // Request function
            () => fetch(searchUrl).then(response => {
              if (response.status === 429) {
                throw { status: 429, message: 'Rate limit reached' };
              }
              if (!response.ok) {
                throw { status: response.status, message: `API search request failed with status ${response.status}` };
              }
              return response.json();
            }),
            // Success handler
            async (data) => {
              // Extract coin data from response
              const coins = data.coins || [];
              
              if (coins.length === 0) {
                searchResults.innerHTML = '<div class="result-item">No results found</div>';
                searchInProgress[searchTerm] = false;
                resolve();
                return;
              }
              
              // Limit to top 5 results to avoid overwhelming the user
              const topResults = coins.slice(0, 5);
              
              // Show temporary results with loading state
              searchResults.innerHTML = '';
              topResults.forEach(coin => {
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item loading-item';
                resultItem.innerHTML = `
                  <img src="${coin.thumb}" class="result-icon" alt="${coin.name}">
                  <div class="result-info">
                    <div class="result-name">${coin.name}</div>
                    <div class="result-symbol">${coin.symbol.toUpperCase()}</div>
                  </div>
                  <div class="search-loading-spinner" style="width: 12px; height: 12px;"></div>
                `;
                searchResults.appendChild(resultItem);
              });
              
              try {
                // Fetch detailed information for each coin - one at a time to avoid rate limits
                const detailedResults = [];
                
                for (const coin of topResults) {
                  try {
                    // Check if we have coin details in the cache
                    const coinCacheKey = `coin_${coin.id}`;
                    const cachedCoinDetails = apiCache.get(coinCacheKey);
                    
                    if (cachedCoinDetails) {
                      detailedResults.push(cachedCoinDetails);
                      continue;
                    }
                    
                    // Increment API request count
                    rateLimitInfo.count++;
                    localStorage.setItem('cg_rate_limit', JSON.stringify(rateLimitInfo));
                    
                    // Check if we're over rate limit protection threshold
                    if (rateLimitInfo.count >= 25) {
                      // Use fallback for remaining coins
                      const fallback = popularCryptos[coin.id] || {
                        id: coin.id,
                        name: coin.name,
                        symbol: coin.symbol.toUpperCase(),
                        price: 'N/A',
                        change: 0
                      };
                      
                      detailedResults.push({
                        id: fallback.id,
                        name: fallback.name,
                        symbol: fallback.symbol,
                        image: coin.large || coin.thumb,
                        current_price: fallback.price === 'N/A' ? 'N/A' : fallback.price,
                        price_change_percentage_24h: fallback.change,
                        total_volume: 'N/A',
                        market_cap: 'N/A'
                      });
                      continue;
                    }
                    
                    const detailUrl = `https://api.coingecko.com/api/v3/coins/${coin.id}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false`;
                    
                    // Fetch with error handling
                    const fetchResult = await fetch(detailUrl);
                    
                    if (fetchResult.status === 429) {
                      // Fall back to basic info on rate limit
                      const fallback = popularCryptos[coin.id] || {
                        price: 'N/A',
                        change: 0
                      };
                      
                      const basicInfo = {
                        id: coin.id,
                        name: coin.name,
                        symbol: coin.symbol.toUpperCase(),
                        image: coin.large || coin.thumb,
                        current_price: fallback.price === 'N/A' ? 'N/A' : fallback.price,
                        price_change_percentage_24h: fallback.change,
                        total_volume: 'N/A',
                        market_cap: 'N/A'
                      };
                      
                      detailedResults.push(basicInfo);
                      // Still cache this limited data
                      apiCache.set(coinCacheKey, basicInfo);
                      
                      // Update our rate limit info
                      rateLimitInfo.count = 30; // Force slowdown
                      localStorage.setItem('cg_rate_limit', JSON.stringify(rateLimitInfo));
                      
                      continue;
                    }
                    
                    if (!fetchResult.ok) {
                      throw new Error(`Failed to get details for ${coin.id}`);
                    }
                    
                    const detail = await fetchResult.json();
                    
                    // Ensure we have valid data with fallbacks
                    const currentPrice = detail.market_data?.current_price?.usd;
                    const priceChange = detail.market_data?.price_change_percentage_24h || 0;
                    const totalVolume = detail.market_data?.total_volume?.usd;
                    const marketCap = detail.market_data?.market_cap?.usd;
                    
                    // Format the data to match our existing structure
                    const coinDetail = {
                      id: detail.id,
                      name: detail.name,
                      symbol: detail.symbol.toUpperCase(),
                      image: detail.image?.large || coin.large || coin.thumb,
                      current_price: currentPrice !== undefined && currentPrice !== null ? currentPrice : 'N/A',
                      price_change_percentage_24h: priceChange,
                      total_volume: totalVolume !== undefined && totalVolume !== null ? totalVolume : 'N/A',
                      market_cap: marketCap !== undefined && marketCap !== null ? marketCap : 'N/A'
                    };
                    
                    detailedResults.push(coinDetail);
                    
                    // Cache the individual coin detail
                    apiCache.set(coinCacheKey, coinDetail);
                    
                    // Wait a bit longer between requests to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 600));
                    
                  } catch (error) {
                    console.error(`Error fetching details for ${coin.id}:`, error);
                    // Return basic info if detailed info can't be fetched
                    detailedResults.push({
                      id: coin.id,
                      name: coin.name,
                      symbol: coin.symbol.toUpperCase(),
                      image: coin.large || coin.thumb,
                      current_price: 'N/A',
                      price_change_percentage_24h: 0,
                      total_volume: 'N/A',
                      market_cap: 'N/A'
                    });
                  }
                }
                
                // Cache the search results
                if (detailedResults.length > 0) {
                  apiCache.set(cacheKey, detailedResults);
                }
                
                // Display the results
                displaySearchResults(detailedResults, searchResults, event);
              } catch (error) {
                console.error('Error processing search details:', error);
                searchResults.innerHTML = '<div class="result-item">Error obtaining details. Using limited data.</div>';
                
                // Use basic info from the search
                const basicResults = topResults.map(coin => ({
                  id: coin.id,
                  name: coin.name,
                  symbol: coin.symbol.toUpperCase(),
                  image: coin.large || coin.thumb,
                  current_price: 'N/A',
                  price_change_percentage_24h: 0,
                  total_volume: 'N/A',
                  market_cap: 'N/A'
                }));
                
                displaySearchResults(basicResults, searchResults, event);
              }
              
              searchInProgress[searchTerm] = false;
              resolve();
            },
            // Error handler
            (error) => {
              console.error('Error searching CoinGecko:', error);
              
              if (error.status === 429) {
                searchResults.innerHTML = '<div class="result-item">API rate limit reached. Using fallback data.</div>';
                
                // If rate limited, use popular cryptos as fallback
                const fallbackResults = Object.values(popularCryptos)
                  .filter(crypto => 
                    crypto.name.toLowerCase().includes(searchTerm) || 
                    crypto.symbol.toLowerCase().includes(searchTerm)
                  )
                  .map(crypto => ({
                    id: crypto.id,
                    name: crypto.name,
                    symbol: crypto.symbol,
                    image: `https://assets.coingecko.com/coins/images/1/small/${crypto.id}.png`,
                    current_price: crypto.price,
                    price_change_percentage_24h: crypto.change,
                    total_volume: 1000000000,
                    market_cap: 10000000000
                  }));
                
                if (fallbackResults.length > 0) {
                  displaySearchResults(fallbackResults, searchResults, event);
                } else {
                  searchResults.innerHTML += '<div class="result-item">No matches in fallback data.</div>';
                }
                
                // Update our rate limit info - assume we're at limit
                rateLimitInfo.count = 30;
                localStorage.setItem('cg_rate_limit', JSON.stringify(rateLimitInfo));
              } else {
                searchResults.innerHTML = '<div class="result-item">Error searching. Try again later.</div>';
              }
              
              searchInProgress[searchTerm] = false;
              reject(error);
            }
          );
        });
        
      } catch (error) {
        console.error('Error in search flow:', error);
        searchResults.innerHTML = '<div class="result-item">Error searching. Try again later.</div>';
        searchInProgress[searchTerm] = false;
      }
    }
    
    /**
     * Display search results in the dropdown
     * @param {Array} cryptos - Array of cryptocurrency data objects
     * @param {HTMLElement} searchResults - The results container element
     * @param {Event} event - The event that triggered the search
     */
    function displaySearchResults(cryptos, searchResults, event) {
      // Clear previous results
      searchResults.innerHTML = '';
      
      // Create result items
      cryptos.forEach(crypto => {
        const resultItem = document.createElement('div');
        resultItem.className = 'result-item';
        
        // Create icon
        let iconHTML = '';
        if (crypto.image) {
          iconHTML = `<img src="${crypto.image}" class="result-icon" alt="${crypto.name}">`;
        } else {
          const backgroundColor = `#${Math.floor(Math.random()*16777215).toString(16)}`;
          iconHTML = `
            <div class="result-icon-fallback" style="background-color: ${backgroundColor}">
              ${crypto.symbol.charAt(0).toUpperCase()}
            </div>
          `;
        }
        
        // Create the URL for the coin on CoinGecko
        const coinUrl = `https://www.coingecko.com/en/coins/${crypto.id}`;
        
        resultItem.innerHTML = `
          ${iconHTML}
          <div class="result-info">
            <div class="result-name">
              <a href="${coinUrl}" target="_blank" rel="noopener noreferrer" class="crypto-name-link" title="View ${crypto.name} on CoinGecko">
                ${crypto.name}
              </a>
            </div>
            <div class="result-symbol">${crypto.symbol.toUpperCase()}</div>
          </div>
        `;
        
        // We'll keep the click behavior on the entire result item to show the modal
        // but clicking specifically on the name link will go to CoinGecko
        resultItem.addEventListener('click', function(e) {
          // Only show modal if the click wasn't on the name link
          if (!e.target.closest('.crypto-name-link')) {
            showCryptoModal(crypto);
            searchResults.classList.remove('active');
            event.target.value = '';
          }
        });
        
        searchResults.appendChild(resultItem);
      });
      
      searchResults.classList.add('active');
    }

    /**
     * Show detailed modal for a cryptocurrency
     * Creates a modal popup with comprehensive information
     * @param {Object} crypto - The cryptocurrency data object
     */
    function showCryptoModal(crypto) {
      // Remove any existing modal
      let existingModal = document.querySelector('.modal-overlay');
      if (existingModal) {
        document.body.removeChild(existingModal);
      }
      
      // Create modal overlay
      const modalOverlay = document.createElement('div');
      modalOverlay.className = 'modal-overlay';
      
      // Create crypto card for modal
      const modalCard = document.createElement('div');
      modalCard.className = 'modal-crypto-card';
      
      // Handle the case where price change might be missing
      const priceChange = crypto.price_change_percentage_24h || 0;
      const isPositive = priceChange > 0;
      
      // Format prices and values correctly
      const formattedPrice = crypto.current_price === 'N/A' ? 'N/A' : `$${formatPrice(crypto.current_price)}`;
      const formattedVolume = crypto.total_volume === 'N/A' ? 'N/A' : `$${formatLargeNumber(crypto.total_volume)}`;
      const formattedMarketCap = crypto.market_cap === 'N/A' ? 'N/A' : `$${formatLargeNumber(crypto.market_cap)}`;
      
      // Create the URL for the coin on CoinGecko
      const coinUrl = `https://www.coingecko.com/en/coins/${crypto.id}`;
      
      modalCard.innerHTML = `
        <button class="modal-close" title="Close cryptocurrency details">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
        <div class="card-header">
          ${crypto.image ? 
            `<div class="crypto-icon" style="background-image: url('${crypto.image}')"></div>` : 
            `<div class="crypto-icon-fallback" style="background-color: #${Math.floor(Math.random()*16777215).toString(16)}">
              ${crypto.symbol.charAt(0).toUpperCase()}
            </div>`
          }
          <div class="crypto-title">
            <div class="crypto-name">
              <a href="${coinUrl}" target="_blank" rel="noopener noreferrer" class="crypto-name-link" title="View ${crypto.name} on CoinGecko">
                ${crypto.name}
              </a>
            </div>
            <div class="crypto-symbol">${crypto.symbol.toUpperCase()}</div>
          </div>
        </div>
        <div class="card-body">
          <div class="price">${formattedPrice}</div>
          <div class="price-change ${isPositive ? 'positive' : 'negative'}">
            ${isPositive ? '↑' : '↓'} ${Math.abs(priceChange).toFixed(2)}%
          </div>
          <div class="stats">
            <div class="stat-item">
              <div class="stat-label">Volume (24h)</div>
              <div class="stat-value">${formattedVolume}</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Market Cap</div>
              <div class="stat-value">${formattedMarketCap}</div>
            </div>
          </div>
        </div>
      `;
      
      // Add modal to the document
      modalOverlay.appendChild(modalCard);
      document.body.appendChild(modalOverlay);
      
      // Add slight delay before adding active class to trigger animation
      setTimeout(() => {
        modalOverlay.classList.add('active');
      }, 10);
      
      // Close modal event
      const closeButton = modalOverlay.querySelector('.modal-close');
      closeButton.addEventListener('click', function() {
        closeModal(modalOverlay);
      });
      
      // Close modal when clicking outside the card
      modalOverlay.addEventListener('click', function(event) {
        if (event.target === modalOverlay) {
          closeModal(modalOverlay);
        }
      });
      
      // Close modal on Escape key
      document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
          closeModal(modalOverlay);
        }
      });
    }

    /**
     * Close the modal with animation
     * @param {HTMLElement} modalOverlay - The modal overlay element
     */
    function closeModal(modalOverlay) {
      modalOverlay.classList.remove('active');
      
      // Remove modal after animation completes
      setTimeout(() => {
        if (modalOverlay.parentNode) {
          document.body.removeChild(modalOverlay);
        }
      }, 300);
    }
  </script>
</body>
</html>
